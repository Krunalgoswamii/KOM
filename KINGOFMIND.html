<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KING OF MIND</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            color: #e1e8f0;
            text-align: center;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
		

        h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #d1e0e0;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.2);
            animation: fadeIn 2s ease-out;
        }

        @keyframes waveAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            background: linear-gradient(270deg, #2e3b4e, #5f6a82, #7890a8, #2e3b4e);
            background-size: 400% 400%;
            animation: waveAnimation 10s infinite ease-in-out;
        }

        /* Reusable Glass Effect Container */
        .glass-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.2);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* UPDATED: input-container now uses glass-container style */
        .input-container {
            margin: 20px auto;
            padding: 20px;
            /* Applying glass effect for consistency */
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.2);
            width: 350px;
            animation: slideIn 1.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 25px 50px;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            border-radius: 10px;
            border: 3px solid red;
            box-shadow: 0px 0px 15px red, 0px 0px 20px white;
            z-index: 9999;
            animation: shake 0.3s infinite alternate;
        }

        /* √∞≈∏‚Äù¬• Fade-out Effect */
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .box {
            display: inline-block;
            width: 60px;
            height: 60px;
            line-height: 60px;
            margin: 8px;
            background-color: #4f5d6b;
            text-align: center;
            border: 2px solid #32414a;
            border-radius: 10px;
            font-weight: bold;
            color: #e1e8f0;
            cursor: pointer;
            transition: transform 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .box:hover {
            background-color: #3a4a59;
            color: #ffffff;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* UPDATED: scoreboard now uses glass-container style */
        .scoreboard {
            margin-top: 20px;
            padding: 20px;
            /* Applying glass effect for consistency */
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(10px); 
            border-radius: 15px;
            display: inline-block;
            box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.2);
            animation: fadeIn 2s ease-out;
        }

        .scoreboard h2 {
            margin: 0 0 15px;
            font-size: 1.8rem;
        }

        .scoreboard div {
            font-size: 1.4rem;
            margin: 10px 0;
            animation: scoreChange 0.5s ease-in-out;
        }

        @keyframes scoreChange {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .result-box {
            background: rgba(34, 34, 34, 0.3);
            backdrop-filter: blur(10px); 
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 6px 15px rgba(255, 255, 255, 0.1); 
            text-align: center;
            font-size: 1.2rem;
            display: inline-block; 
            max-width: 80%;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .result-box:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 20px rgba(255, 255, 255, 0.2);
        }

        /* √∞≈∏≈Ω¬≠ Score Change Animation */
        @keyframes scoreChange {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .score-changes li {
            animation: scoreChange 0.4s ease-in-out;
        }

        /* √¢≈ì‚Ä¶ Winner Green Glowing Effect */
        .highlight-green {
            color: #4CAF50;
            font-weight: bold;
            text-shadow: 0px 0px 10px rgba(76, 175, 80, 0.8);
        }

        /* √¢ ≈í Eliminated Red Glow */
        .highlight-red {
            color: #E74C3C;
            font-weight: bold;
            text-shadow: 0px 0px 10px rgba(231, 76, 60, 0.8);
        }

        /* √¢≈°¬† Yellow Glow for Warnings */
        .highlight-yellow {
            color: #F1C40F;
            font-weight: bold;
            text-shadow: 0px 0px 10px rgba(241, 196, 15, 0.8);
        }

        /* √∞≈∏≈Ω¬Ø Blue for Target Answer */
        .highlight-blue {
            color: #3498DB;
            font-weight: bold;
            text-shadow: 0px 0px 10px rgba(52, 152, 219, 0.8);
        }

        /* √∞≈∏‚Äú≈ì Rules Box Soft Glass Effect */
        .rules-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
        }

        /* √∞≈∏≈Ω¬≤ Numbers & Score List Styling */
        .selected-numbers, .score-changes {
            max-height: 300px; 
            overflow-y: auto; 
        }

        .selected-numbers li, .score-changes li {
            padding: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 1.1rem;
        }
        #undo-btn, #history-btn {
            background: linear-gradient(90deg, #4cafaf, #6684bb); 
            color: white;
            padding: 12px 18px;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        #undo-btn:hover, #history-btn:hover {
            transform: scale(1.05);
            box-shadow: 0px 0px 15px rgba(76, 175, 80, 0.8);
        }
        
        /* NEW: History button in final winner screen */
        #history-final-btn {
            background: linear-gradient(90deg, #6684bb, #4cafaf); 
            color: white;
            padding: 12px 18px;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        #history-final-btn:hover {
            transform: scale(1.05);
            box-shadow: 0px 0px 15px rgba(76, 175, 80, 0.8);
        }


        /* √¢≈æ¬° Next Button Animation */
        .next-btn {
            background: linear-gradient(90deg, #4cafaf, #6684bb);
            color: white;
            padding: 12px 18px;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .next-btn:hover {
            transform: scale(1.05);
            box-shadow: 0px 0px 15px rgba(76, 175, 80, 0.8);
        }


        button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 1.1rem;
            color: #fff;
            background-color: #32414a;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }

        button:hover {
            background-color: #2b3748;
            transform: scale(1.05);
        }

        .player-name {
            margin-bottom: 10px;
        }

        .rule-book {
            margin-top: 30px;
            padding: 15px;
            background-color: #2e3b4e;
            border-radius: 15px;
            font-size: 1.2rem;
            color: #e1e8f0;
            animation: slideIn 1.5s ease-out;
        }

        .rule-book h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .scoreboard div, .result p {
            font-size: 1.6rem;
        }
        .selected-numbers li {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffffff; 
            text-shadow: 2px 2px 5px rgba(75, 241, 241, 0.116); 
            padding: 10px 0; 
        }
        
        /* UPDATED: eliminated-box now uses glass-container style (with red tint) */
        #eliminated-box {
            display: none;
            background: rgba(255, 77, 77, 0.2); /* Light red transparent */
            backdrop-filter: blur(10px); /* Added glass blur */
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(255, 0, 0, 0.3); /* Red glow effect */
            text-align: center;
            animation: fadeInScale 0.8s ease-in-out; 
            transition: all 0.5s ease-in-out;
        }

        #eliminated-box h2 {
            color: #ff4d4d; /* Bright red title */
        }

        #eliminated-table {
            width: 100%;
            border-collapse: collapse;
        }

        #eliminated-table th, #eliminated-table td {
            border: 1px solid rgba(255, 0, 0, 0.5);
            padding: 8px;
            text-align: center;
            color: white;
        }

        #eliminated-table th {
            background: rgba(255, 77, 77, 0.6);
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .reverse-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 60px;
            font-size: 3.5rem;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
            border: 5px solid rgba(255, 0, 0, 0.9);
            box-shadow: 0px 0px 15px red, 0px 0px 20px blue;
            z-index: 1000;
            animation: glitchText 0.1s infinite alternate, shakeEffect 0.2s infinite alternate;
        }

        /* √∞≈∏≈í≈∏ Glitch Text Animation */
        @keyframes glitchText {
            0% { text-shadow: 3px 3px red, -3px -3px blue; transform: skewX(-10deg); }
            50% { text-shadow: -3px 3px red, 3px -3px blue; transform: skewX(10deg); }
            100% { text-shadow: 3px -3px red, -3px 3px blue; transform: skewX(-10deg); }
        }

        /* √∞≈∏≈í¬™√Ø¬∏  Screen Shake Effect */
        @keyframes shakeEffect {
            0% { transform: translate(-50%, -50%) scale(1.05) rotate(2deg); }
            50% { transform: translate(-50%, -50%) scale(1) rotate(-2deg); }
            100% { transform: translate(-50%, -50%) scale(1.05) rotate(2deg); }
        }

        /* √¢≈°¬° Neon Flash Effect */
        .reverse-flash {
            animation: screenFlash 0.5s infinite alternate;
        }

        @keyframes screenFlash {
            0% { background: rgba(255, 0, 0, 0.2); }
            100% { background: rgba(0, 0, 255, 0.2); }
        }

        #winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            font-size: 2.5rem;
            font-family: Arial, sans-serif;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease-in-out, visibility 0.5s;
            padding: 20px;
        }

        /* Show overlay with animation */
        #winner-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        #winner-text {
            font-size: 3.5rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        /* Glowing Winner Name */
        .glow {
            font-weight: bold;
            animation: glowAnimation 1.5s infinite alternate;
        }

        @keyframes glowAnimation {
            0% { text-shadow: 0 0 10px #e61f1f, 0 0 20px #ff7300; } 
            20% { text-shadow: 0 0 10px #f79c51, 0 0 20px #e9e639; } 
            40% { text-shadow: 0 0 10px #f8f661, 0 0 20px #48ff00; } 
            60% { text-shadow: 0 0 10px #48ff00, 0 0 20px #00fffb; } 
            80% { text-shadow: 0 0 10px #00fffb, 0 0 20px #8000ff; } 
            100% { text-shadow: 0 0 10px #8000ff, 0 0 20px #ff0000; } 
        }

        /* Winner trophy */
        .trophy {
            font-size: 4rem;
            margin-top: 10px;
        }

        /* Restart Button */
        #restart-btn {
            background: gold;
            color: black;
            border: none;
            padding: 15px 30px;
            font-size: 1.5rem;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 10px;
            transition: 0.3s;
        }

        #restart-btn:hover {
            background: darkgoldenrod;
        }

        /* Eliminated Players Section */
        #eliminated-players {
            margin-top: 20px;
            font-size: 1.2rem;
            text-align: left;
        }

        .eliminated-player {
            margin: 5px 0;
            padding: 5px;
        }

        .badge {
            font-size: 1.5rem;
            margin-left: 10px;
        }
        /* Confetti Animation */
        @keyframes confetti {
            0% { transform: translateY(0); }
            100% { transform: translateY(100vh); }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: gold;
            top: -10px;
            opacity: 0.8;
            animation: confetti 3s linear infinite;
        }
        .KG {
            position: fixed;
            font-family: 'Arial', sans-serif;
            top: 10px;
            right: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 1px 1px 2px #000;
            z-index: 9999;
            pointer-events: none; 
            font-family: 'Arial', sans-serif;
            letter-spacing: 1px;
        }
        body.normal-mode {
            background: linear-gradient(270deg, #2e3b4e, #5f6a82, #7890a8, #2e3b4e);
            background-size: 400% 400%;
            animation: waveAnimation 10s infinite ease-in-out;
        }

        /* √∞≈∏≈í¬™√Ø¬∏  Reverse Mode Background (Glitchy Red-Blue Animation) */
        body.reverse-mode {
            background: linear-gradient(270deg, red, blue, purple, red);
            background-size: 500% 500%;
            animation: reverseWave 3s infinite ease-in-out;
        }
        @keyframes reverseWave {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* --- NEW HISTORY MODAL STYLES --- */
        .history-modal-overlay {
            display: none; 
            position: fixed;
            z-index: 10000; /* FIX: Increased Z-Index to be above #winner-overlay (9999) */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8); 
            backdrop-filter: blur(5px);
        }

        .history-modal-content {
            background: rgba(46, 59, 78, 0.95); /* Darker background */
            margin: 5% auto; 
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 700px;
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.2);
            animation: slideInModal 0.5s ease-out;
            text-align: left;
        }

        @keyframes slideInModal {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close-btn {
            color: #fff;
            float: right;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
        }

        .history-round {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
        }

        .history-round h3 {
            margin-top: 0;
            color: #4CAF50;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        .history-round ul {
            list-style: none;
            padding: 0;
        }
        .history-round li {
            padding: 5px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

    </style>
</head>
<body>
    <div id="winner-overlay">
        <h1 id="winner-text"></h1>
        <div class="trophy">üèÜ</div>
        <p id="winner-badge"></p>
        <div id="eliminated-players"></div>
        <div style="margin-top: 20px;">
            <button id="history-final-btn" onclick="showHistory()" style="margin-right: 15px;">üïí Game History</button>
            <button id="restart-btn" onclick="restartGame()">Restart Game</button>
        </div>
    </div>
        
    <h1>KING OF MIND</h1>
	<div class="KG">By Krunal Goswami</div>
	
    <div id="playerSetup" class="input-container">
        <h2>Enter Player Names</h2>
        <div id="playerInputs"></div>
        <label for="numPlayers">Number of Players:</label>
        <input type="number" id="numPlayers" min="2" max="5" value="5">
        <button onclick="startGame()">Start Game</button>
    </div>
    
    <div style="margin-top: 20px;">
        <button id="undo-btn" onclick="undoMove()" style="display:none;">‚Æ™ Undo</button>
        <button id="history-btn" onclick="showHistory()" style="display:none; margin-left: 10px;">üïí History</button>
    </div>

    <div id="reverse-mode-popup" class="reverse-popup">‚ö†Ô∏è REVERSE MODE ACTIVATED ‚ö†Ô∏è</div>
    <div id="mode-status" style="font-size: 2rem; font-weight: bold; margin-top: 15px; color: red; text-shadow: 2px 2px 5px rgba(255,0,0,0.7);"></div>

    <div style="display: flex; justify-content: center; gap: 20px;">
        <div id="scoreboard" class="scoreboard"></div>
        
        <div id="eliminated-box" class="scoreboard" style="display: none;">
            <h2>Eliminated Players</h2>
            <table id="eliminated-table" border="1" style="width: 100%; color: white; text-align: left;">
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Round</th>
                        <th>Wins</th>
                        <th>Losses</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <div id="game"></div>
    <div id="elimination-popup" class="popup">
        <h2 id="elimination-message"></h2>
    </div>

    <div id="result" class="result" style="display: none;"></div>

    <div class="rule-book">
        <h2>Game Rules</h2>
        <p>Players select a number between 0 and 100. The average of the selected numbers is calculated and multiplied by 0.8.</p>
        <p>The player whose number is closest to the result wins and gains +1 point. Other players lose 1 point.</p>
        <p>If a player's score reaches -10, they are eliminated from the game.</p>
        <h4>Special Rules After Elimination</h4>
        <p>4 players Playing: Agar 2 ya usse jyada logo ne same number select kiya he & wo hi number win hota he tobhi wo players ke -1 honge</p>
        <p>3 players Playing: Agar Answer ka number & kosi 1 player ka number same aaya to , the loser penalty will doubled.</p>
        <p>2 players Playing: If someone chooses 0, the player who chooses 100 is the winner</p>
        <h4>Special Rules 2</h4>
        <p>Reverse Mode: Farthest number from the answer wins this round</p>
    </div>
    
    <div id="history-modal" class="history-modal-overlay" style="display: none;">
        <div class="history-modal-content">
            <span class="close-btn" onclick="closeHistoryModal()">&times;</span>
            <h2>Game History</h2>
            <div id="history-list">
                </div>
        </div>
    </div>

    <script>
        let players = [];
        let currentPlayerIndex = 0;
        let allNumbersSelected = false;
        let roundCount = 1;
        let numPlayers = 5;
        let reverseModeActive = false;
        let normalRoundsBeforeReverse = Math.floor(Math.random() * 2) + 3;
        let reverseRoundCount = 0;
        let historyStack = [];
        let winStreak = {};
        let loseStreak = {};
        let roundHistory = []; // NEW: Array to store completed round results
        let eliminatedPlayers = []; // Global array to track eliminated players

        function setNormalBackground() {
            document.body.className = 'normal-mode';
        }

        function setReverseBackground() {
            document.body.className = 'reverse-mode';
        }
        function checkReverseMode() {
            const modeStatus = document.getElementById('mode-status');
            if (players.length > 2) { 
                if (reverseModeActive) {
                    reverseModeActive = false;
                    reverseRoundCount = 0;
                    normalRoundsBeforeReverse = Math.floor(Math.random() * 2) + 3;
                    modeStatus.innerHTML = "";
                } else if (roundCount % normalRoundsBeforeReverse === 0 && reverseRoundCount === 0) {
                    reverseModeActive = true;
                    reverseRoundCount = 1;
                    showReverseModePopup();
                    modeStatus.innerHTML = "‚ö° Reverse Mode Active!";
                }
            } else {
                reverseModeActive = false;
                modeStatus.innerHTML = ""; 
            }
        }
        function undoMove() {
            if (historyStack.length === 0) {
                alert("‚ö†Ô∏è Nothing to undo!");
                return;
            }

            let lastState = historyStack.pop();

            players = JSON.parse(JSON.stringify(lastState.playersState));
            currentPlayerIndex = lastState.currentPlayerIndex;
            roundCount = lastState.roundCount;
            allNumbersSelected = lastState.allNumbersSelected;
            winStreak = JSON.parse(JSON.stringify(lastState.winStreakState)); 
            loseStreak = JSON.parse(JSON.stringify(lastState.loseStreakState));
            eliminatedPlayers = JSON.parse(JSON.stringify(lastState.eliminatedPlayersState));
            roundHistory = JSON.parse(JSON.stringify(lastState.roundHistoryState));

            
            if (historyStack.length === 0) {
                document.getElementById('undo-btn').style.display = 'none';
            }

            document.getElementById('result').style.display = 'none';
            updateEliminatedTable(); 
            renderGame();
        }

        function showReverseModePopup() {
            let popup = document.getElementById('reverse-mode-popup');
            setReverseBackground();
            
            document.body.classList.add("reverse-flash");
            
            popup.style.display = "block";
            setTimeout(() => {
                popup.style.display = "none";
                document.body.classList.remove("reverse-flash"); // Remove flash effect
                setNormalBackground();
            }, 3000);
        }
        
        function generatePlayerInputs() {
            const playerInputsDiv = document.getElementById('playerInputs');
            playerInputsDiv.innerHTML = ''; 
            numPlayers = document.getElementById('numPlayers').value;

            for (let i = 1; i <= numPlayers; i++) {
                const inputDiv = document.createElement('div');
                inputDiv.classList.add('player-name');
                inputDiv.innerHTML = ` 
                    <label for="player${i}">Player ${i} Name:</label>
                    <input type="text" id="player${i}" placeholder="Enter Player ${i} Name">
                `;
                playerInputsDiv.appendChild(inputDiv);
            }
        }

        document.getElementById('numPlayers').addEventListener('change', generatePlayerInputs);
        generatePlayerInputs(); 

        function startGame() {
            players = [];
            const playerNames = new Set();
            let duplicateFound = false;

            for (let i = 1; i <= numPlayers; i++) {
                const playerName = document.getElementById(`player${i}`).value.trim();
                
                if (playerName) {
                    if (playerNames.has(playerName)) {
                        duplicateFound = true;
                        break;
                    }
                    playerNames.add(playerName);

                    players.push({ 
                        id: i, 
                        name: playerName, 
                        score: 0, 
                        selectedNumber: null, 
                        wins: 0, 
                        losses: 0 
                    });
                }
            }

            if (duplicateFound) {
                alert('‚ö†Ô∏è Please enter unique names for all players.');
                return;
            }

            players.forEach(player => {
                winStreak[player.name] = 0;
                loseStreak[player.name] = 0;
            });

            if (players.length < 2) {
                alert('Please enter at least 2 players');
                return;
            }

            document.getElementById('playerSetup').style.display = 'none';
            renderGame();
        }

        function renderGame() {
            const gameDiv = document.getElementById('game');
            gameDiv.innerHTML = '';

            const currentPlayer = players[currentPlayerIndex];
            const playerDiv = document.createElement('div');
            playerDiv.classList.add('player');
            playerDiv.innerHTML = `<h2>${currentPlayer.name}'s Turn</h2>`;
            for (let i = 0; i <= 100; i++) {
                const box = document.createElement('div');
                box.classList.add('box');
                box.textContent = i;
                box.onclick = () => selectNumber(i);
                
                // Highlight selected number if it was selected in the current turn before undo
                if (players.some(p => p.selectedNumber === i)) {
                    // This logic is complex for partial undo, keeping it simple for now
                    // You might want to grey out numbers that have ALREADY been picked by ANY player
                }

                playerDiv.appendChild(box);
            }

            gameDiv.appendChild(playerDiv);
            renderScoreboard();
        }

        function renderScoreboard() {
            const scoreboardDiv = document.getElementById('scoreboard');
            scoreboardDiv.innerHTML = `<h2>Scoreboard (Round ${roundCount})</h2>`;

            players.forEach(player => {
                const scoreDiv = document.createElement('div');
                scoreDiv.textContent = `${player.name}: ${player.score}`;
                scoreboardDiv.appendChild(scoreDiv);
            });
        }

        function selectNumber(number) {
            if (allNumbersSelected) return;
            const currentPlayer = players[currentPlayerIndex];
            
            // Push current state before making the move
            historyStack.push({
                playersState: JSON.parse(JSON.stringify(players)), 
                currentPlayerIndex: currentPlayerIndex,
                roundCount: roundCount,
                allNumbersSelected: allNumbersSelected,
                winStreakState: JSON.parse(JSON.stringify(winStreak)), 
                loseStreakState: JSON.parse(JSON.stringify(loseStreak)),
                eliminatedPlayersState: JSON.parse(JSON.stringify(eliminatedPlayers)),
                roundHistoryState: JSON.parse(JSON.stringify(roundHistory))
            });

            currentPlayer.selectedNumber = number;

            document.getElementById('undo-btn').style.display = 'inline-block';

            currentPlayerIndex++;
            if (currentPlayerIndex >= players.length) {
                allNumbersSelected = true;
                showResultButton();
            } else {
                renderGame();
            }
        }

        function showResultButton() {
            const resultDiv = document.getElementById('result');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <button onclick="showResults()">Show Results</button>
            `;
        }
        

        function showResults() {
            const selectedNumbers = players.map(p => p.selectedNumber);
            const average = selectedNumbers.reduce((sum, num) => sum + num, 0) / players.length;
            const Answer = Math.round(average * 0.8);
            let winners = [];
            let sameNumberCounts = {};
            let rulesApplied = [];
            let scoreChanges = [];
            let bestDifference = reverseModeActive ? -Infinity : Infinity;
            if (reverseModeActive) {
                rulesApplied.push("‚ö†Ô∏è <strong>Reverse Mode:</strong> <span class='highlight-red'>Farthest number from the answer wins this round!</span>");
            }

            // Count occurrences of selected numbers
            selectedNumbers.forEach(num => {
                sameNumberCounts[num] = (sameNumberCounts[num] || 0) + 1;
            });
            
            // Find closest players to the Answer
            players.forEach(player => {
                const diff = Math.abs(player.selectedNumber - Answer);
                
                if (reverseModeActive) { 
                    if (diff > bestDifference) {
                        bestDifference = diff;
                        winners = [player];
                    } else if (diff === bestDifference) {
                        winners.push(player);
                    }
                } else { 
                    if (diff < bestDifference) {
                        bestDifference = diff;
                        winners = [player];
                    } else if (diff === bestDifference) {
                        winners.push(player);
                    }
                }
            });
            let penaltyMultiplier = 1; 

            // Store player data before score changes for history
            const currentPlayersSnapshot = players.map(p => ({ 
                ...p, 
                // Deep copy wins/losses at this moment
                winsBefore: p.wins, 
                lossesBefore: p.losses 
            })); 

            // --- APPLY RULES BASED ON PLAYER COUNT ---
            if (players.length === 2) {
                const playerWithZero = players.find(p => p.selectedNumber === 0);
                const playerWithHundred = players.find(p => p.selectedNumber === 100);

                if (playerWithZero && playerWithHundred) {
                    winners = [playerWithHundred];
                    rulesApplied.push("üèÜ <strong>Rule (2 Players):</strong> <span class='highlight-green'>100 wins automatically (0 vs 100)</span>.");
                    // No score change applied here, applied below in winners loop.
                } else if (winners.some(player => player.selectedNumber === Answer)) {
                    penaltyMultiplier = 2;
                    rulesApplied.push("‚ö†Ô∏è <strong>Rule (2 Players):</strong> <span class='highlight-yellow'>Exact match ‚Üí Loser penalty doubled.</span>");
                }
            }

            // Update streaks
            players.forEach(player => {
                if (winners.includes(player)) {
                    winStreak[player.name]++;
                    loseStreak[player.name] = 0; 
                } else {
                    winStreak[player.name] = 0;
                    loseStreak[player.name] += 1; 
                }
            });

            if (players.length <= 3) {
                if (winners.some(player => player.selectedNumber === Answer)) {
                    penaltyMultiplier = 2;
                    rulesApplied.push("‚ö†Ô∏è <strong>Rule (3 Players):</strong> <span class='highlight-yellow'>Exact match ‚Üí Loser penalty doubled.</span>");
                }
            }
            
            let duplicateWinnerPenaltyApplied = false;
            let playersPenalizedForDuplicate = [];

            if (players.length <= 4) {
                Object.keys(sameNumberCounts).forEach(num => {
                    if (sameNumberCounts[num] > 1) {
                        let playersWithDuplicate = players.filter(p => p.selectedNumber == num);
                        let anyWinner = playersWithDuplicate.some(p => winners.includes(p));

                        if (anyWinner) {
                            playersPenalizedForDuplicate.push(...playersWithDuplicate);
                            duplicateWinnerPenaltyApplied = true;
                        }
                    }
                });
            }

            // Apply +1 to winners (Only non-duplicate winners get +1 here)
            winners.forEach(winner => {
                let isPenalized = playersPenalizedForDuplicate.includes(winner);
                if (!isPenalized) {
                    winner.score += 1;
                    winner.wins += 1;
                    scoreChanges.push(`‚úÖ <span class='highlight-green'>${winner.name} gained 1 point (Closest to Answer)</span>`);
                }
            });

            // Apply -2 point penalty to duplicate winners
            if (duplicateWinnerPenaltyApplied) {
                rulesApplied.push("üö´ <strong>Rule (4 Players):</strong> <span class='highlight-red'>Duplicate number winner ‚Üí -2 points penalty.</span>");
                playersPenalizedForDuplicate.forEach(player => {
                    if (winners.includes(player)) { // Only if they were a winner
                        player.score -= 2;
                        player.wins += 1; // Count as win but negative points
                        scoreChanges.push(`‚ùå <span class='highlight-red'>${player.name} lost 2 point (Duplicate Winner Rule)</span>`);
                    }
                });
            }
            

            // Apply penalties to losers
            players.forEach(player => {
                if (!winners.includes(player) && player.selectedNumber !== null) {
                    let penalty = 1; // Default normal penalty
                    let penaltyText = "";

                    if (penaltyMultiplier === 2) { 
                        penalty = 2;
                        penaltyText = " (Exact Match Double Penalty)";
                    }

                    if (players.length === 2 && loseStreak[player.name] > 2) {
                         penalty = Math.pow(2, loseStreak[player.name] - 3) * 2; 
                         penaltyText = " (Lose Streak Compounding Penalty)";
                    }
                    
                    player.score -= penalty;
                    player.losses += 1;

                    scoreChanges.push(`‚ö† <span class='highlight-yellow'>${player.name} lost ${penalty} point(s)${penaltyText}</span>`);
                }
            });

            // Store player scores from the moment of calculation (before potential elimination)
            let roundEndScores = players.map(p => ({ 
                name: p.name, 
                score: p.score 
            }));


            // --- NEW: History Storage ---
            const winnerNames = winners.map(w => w.name);
            const finalScoreChanges = scoreChanges.map(change => {
                // Keep only the player name and the change description (without HTML tags)
                let text = change.replace(/<[^>]+>/g, '').trim();
                let match = text.match(/^(.*?) (gained|lost) (.*)/);
                if(match) {
                    return { name: match[1], change: (match[2] === 'gained' ? '+' : '-') + match[3].split('point')[0].trim() };
                }
                return { name: text.split(':')[0], change: "" }; // Fallback
            });

            let currentPlayersHistoryData = currentPlayersSnapshot.map(p => {
                let scoreInfo = finalScoreChanges.find(c => c.name === p.name);
                let scoreChange = scoreInfo ? scoreInfo.change : '¬±0';

                // Check for current elimination status before filtering
                let isEliminatedInThisRound = false;
                if (roundEndScores.find(rs => rs.name === p.name).score <= -10) {
                     isEliminatedInThisRound = true;
                }

                return {
                    name: p.name,
                    selectedNumber: p.selectedNumber,
                    finalScore: roundEndScores.find(rs => rs.name === p.name).score,
                    scoreChange: scoreChange,
                    eliminated: isEliminatedInThisRound ? true : false,
                };
            });
            
            const currentRoundData = {
                round: roundCount,
                answer: Answer.toFixed(2),
                isReverseMode: reverseModeActive,
                winners: winnerNames,
                rules: rulesApplied.map(rule => rule.replace(/<[^>]+>/g, '')), 
                players: currentPlayersHistoryData
            };
            roundHistory.push(currentRoundData);
            // --- END History Storage ---

            // Track and Remove eliminated players
            currentPlayersSnapshot.forEach(player => {
                if (roundEndScores.find(rs => rs.name === player.name).score <= -10) {
                    // Check if already eliminated (shouldn't happen, but good practice)
                    if(!eliminatedPlayers.some(ep => ep.name === player.name)) {
                        // Use the final wins/losses which were updated above
                        const eliminatedFinalState = players.find(p => p.name === player.name);
                        
                        eliminatedPlayers.push({
                            name: player.name,
                            roundEliminated: roundCount,
                            wins: eliminatedFinalState.wins,
                            losses: eliminatedFinalState.losses
                        });
                        showEliminationPopup(player.name); 
                    }
                }
            });

            players = players.filter(player => player.score > -10);
            
            if (players.length <= 1) {
                showFinalResults();
                return;
            }

            // Update UI with new scoreboard
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `
                <div class="result-box">
                    <h2><strong>Answer:</strong> <span class="highlight-blue">${Answer.toFixed(2)}</span></h2>
                    <div class="rules-box">
                        ${rulesApplied.length ?
                        rulesApplied.map(rule => `<p>${rule}</p>`).join('') : `<p>No special rule applied.</p>`}
                    </div>

                    <p><strong>üèÜ Winners:</strong> <span class="highlight-green">${winners.map(w => w.name).join(', ')}</span></p>

                    <h3><ul class="selected-numbers">
                        ${currentPlayersSnapshot.map(p => `<li><strong>${p.name}:</strong> ${p.selectedNumber}</li>`).join('')}
                    </ul></h3>

                    <p><strong>Score Changes:</strong></p>
                    <ul class="score-changes">
                        ${scoreChanges.map(change => `<li>${change}</li>`).join('')}
                    </ul>

                    ${eliminatedPlayers.length > 0 ?
                    `
                        <div class="eliminated-box">
                            <h3>‚ùå Eliminated Players</h3>
                            <ul>
                                ${eliminatedPlayers.map(ep => `
                                <li>
                                    <strong>${ep.name}</strong> (Round ${ep.roundEliminated}) <br>
                                </li>
                                `).join('')}
                            </ul>
                        </div>
                    ` : ''}

                    <button class="next-btn" onclick="nextRound()">‚Üí Next Round</button>
                </div>
            `;
            updateEliminatedTable(); // Update the sidebar table
            renderScoreboard();
        }

        function showEliminationPopup(playerName) {
            if (players.length <= 1) return;
            let funnyAchievements = [
                "Aukaat Dikha Di Bhai Saab!",
                "Popat Ho Gaya!",
                "Moye Moye Moment!",
                "Galti Se Mistake Ho Gaya!",
                "Confidence Tha Par Zyada Ho Gaya!",
                "Beta Tumse Na Ho Payega!",
                "Mere baski nahi ye game!",
                "late ho raha he, Me ja raha hu",
                "System Failure!",
                "Ghutno se nhi khelna tha!",
                "Chalo to me chalta hu!"
            ];

            let randomAchievement = funnyAchievements[Math.floor(Math.random() * funnyAchievements.length)];
            let message = ` ${playerName}! <br> ${randomAchievement}`;

            let popup = document.getElementById("elimination-popup");
            popup.innerHTML = `<h2>${message}</h2>`;
            popup.style.display = "block";

            popup.onclick = function () {
                popup.style.display = "none";
            };
        }
        function updateEliminatedTable() {
            const eliminatedBox = document.getElementById("eliminated-box");
            const eliminatedTable = document.getElementById("eliminated-table").getElementsByTagName("tbody")[0];

            if (eliminatedPlayers.length > 0) {
                eliminatedBox.style.display = "block"; 
                eliminatedBox.style.opacity = "0"; 
                setTimeout(() => {
                    eliminatedBox.style.opacity = "1"; 
                    eliminatedBox.style.transform = "scale(1)";
                }, 100); 
            } else {
                eliminatedBox.style.display = "none";
            }

            eliminatedTable.innerHTML = ""; 

            eliminatedPlayers.forEach(player => {
                let row = eliminatedTable.insertRow();
                row.innerHTML = `
                    <td>${player.name}</td>
                    <td>${player.roundEliminated}</td>
                    <td>${player.wins}</td>
                    <td>${player.losses}</td>
                `;
            });
        }

        function nextRound() {
            currentPlayerIndex = 0;
            allNumbersSelected = false;
            players.forEach(player => player.selectedNumber = null);
            roundCount++; 
            checkReverseMode();
            document.getElementById('result').style.display = 'none';
            document.getElementById('history-btn').style.display = 'inline-block'; // Show history button after first round
            renderGame();
        }

        function showFinalResults() {
            // Check if there is exactly one winner left
            if (players.length !== 1) {
                // This case should ideally not happen if elimination logic is perfect, 
                // but handles a scenario where all players are eliminated simultaneously.
                // Or if the last remaining player somehow has score <= -10 (which is filtered out)
                alert("Game ended, but winner could not be determined. Restarting.");
                restartGame();
                return;
            }

            const winner = players[0]; // The only player remaining is the winner
            const overlay = document.getElementById('winner-overlay');
            const winnerText = document.getElementById('winner-text');
            const winnerBadge = document.getElementById('winner-badge');
            const eliminatedPlayersDiv = document.getElementById('eliminated-players');
            
            const winnerAchievements = [
                { title: "üèÜ KING OF MIND", emoji: "üëë" },
                { title: "üî• Unstoppable Champion", emoji: "üî•" },
                { title: "üéØ Master of Mind Games", emoji: "üéØ" },
                { title: "‚ö° Lightning Fast Thinker", emoji: "‚ö°" },
                { title: "ü§ñ AI-Level Genius", emoji: "ü§ñ" },
                { title: "üéØ Precision King", emoji: "üéØ" },
                { title: "üîÆ Future Predictor", emoji: "üîÆ" },
                { title: "üí° Big Brain Time", emoji: "üí°" },
                { title: "üòÇ Apun hi j BHAGVAN he", emoji: "üòÇ" },
                { title: "üòè Sneaky Mastermind", emoji: "üòè" }
            ];
            const eliminatedAchievements = [
                { title: "üëª Aapse Nahi Hoga", emoji: "üëª" },
                { title: "üòÇ The Joker", emoji: "üòÇ" },
                { title: "üöÄ Shuru Hote hi Khatam", emoji: "üöÄ" },
                { title: "üéØ King of Bad Luck", emoji: "üéØ" },
                { title: "üïµÔ∏è‚Äç‚ôÇÔ∏è Mysterious Player", emoji: "üïµÔ∏è‚Äç‚ôÇÔ∏è" },
                { title: "üß† Dimag se Khelna he Ghutno se Nahi", emoji: "üß†" },
                { title: "üòÇ Sunday Aana Mast Nah Dhoh ke", emoji: "üòÇ" },
                { title: "üêí Bandar Kya Jane Adrak ka Swad", emoji: "üêí" },
                { title: "üò≠ Ajeeb bezzati hai yaar!", emoji: "üò≠" },
                { title: "üòÇ Confidence tha par zyada ho gaya!", emoji: "üòÇ" }

            ];
            let randomWinnerBadge = winnerAchievements[Math.floor(Math.random() * winnerAchievements.length)];
            winnerBadge.innerHTML = `${randomWinnerBadge.emoji} <b>${randomWinnerBadge.title}</b>`;
            
            winnerText.innerHTML = `KING OF MIND is <span class="glow">${winner.name}</span>!`;
            
            // Only list players who were eliminated due to score <= -10
            let eliminatedHTML = "<h2>Eliminated Players (By Score)</h2><ul>";
            if (eliminatedPlayers.length === 0) {
                 eliminatedHTML += "<li>No players were eliminated during the game.</li>";
            } else {
                eliminatedPlayers.forEach(player => {
                    let randomEliminatedBadge = eliminatedAchievements[Math.floor(Math.random() * eliminatedAchievements.length)];
                    // UPDATED: Added Wins and Losses count
                    eliminatedHTML += `<li><strong>${player.name}</strong> - Round ${player.roundEliminated} <br> (Wins: <span class='highlight-green'>${player.wins}</span>, Losses: <span class='highlight-red'>${player.losses}</span>) (${randomEliminatedBadge.emoji} ${randomEliminatedBadge.title})</li>`;
                });
            }
            eliminatedHTML += "</ul>";

            eliminatedPlayersDiv.innerHTML = eliminatedHTML;
            overlay.classList.add('show');

            for (let i = 0; i < 50; i++) {
                let confetti = document.createElement("div");
                confetti.classList.add("confetti");
                confetti.style.left = Math.random() * 100 + "vw";
                confetti.style.animationDuration = (Math.random() * 3 + 2) + "s";
                document.body.appendChild(confetti);
            }
        }


        function restartGame() {
            location.reload();
        }

        // --- NEW HISTORY FUNCTIONS ---

        function showHistory() {
            const historyList = document.getElementById('history-list');
            const historyModal = document.getElementById('history-modal');
            historyList.innerHTML = '';

            // History is displayed from latest to oldest
            const reversedHistory = [...roundHistory].reverse(); 

            if (reversedHistory.length === 0) {
                historyList.innerHTML = '<p>No rounds have been completed yet.</p>';
            } else {
                reversedHistory.forEach(round => {
                    let playerList = round.players.map(p => {
                        let scoreText = p.scoreChange; 
                        let colorClass = 'highlight-yellow'; 
                        let eliminatedBadge = '';

                        if (scoreText.includes('+')) {
                             colorClass = 'highlight-green';
                        } else if (scoreText.includes('-')) {
                             colorClass = 'highlight-red';
                        }
                        
                        // Check if player was eliminated in this round
                        if (p.eliminated) {
                            eliminatedBadge = ' ‚ùå <span class="highlight-red">Eliminated!</span>';
                        }
                        
                        // New logic: Only show score change if it's not "¬±0"
                        let changeDisplay = scoreText === '¬±0' ? '' : `(Change: <span class="${colorClass}">${scoreText.split('point')[0].trim()}</span>)`;


                        return `<li><strong>${p.name}:</strong> ${p.selectedNumber} (Score: ${p.finalScore}) ${changeDisplay} ${eliminatedBadge}</li>`;
                    }).join('');
                    
                    const reverseText = round.isReverseMode ? ' (REVERSE MODE)' : '';
                    const winnerText = round.winners.length > 0 ? `<p><strong>Winner(s):</strong> <span class="highlight-green">${round.winners.join(', ')}</span></p>` : `<p><strong>Winner(s):</strong> <span class="highlight-yellow">No Clear Winner</span></p>`;

                    historyList.innerHTML += `
                        <div class="history-round">
                            <h3>Round ${round.round} ${reverseText}</h3>
                            <p><strong>Answer:</strong> <span class="highlight-blue">${round.answer}</span></p>
                            ${winnerText}
                            <h4>Player Selections:</h4>
                            <ul>${playerList}</ul>
                        </div>
                    `;
                });
            }

            historyModal.style.display = 'block';
        }

        function closeHistoryModal() {
            document.getElementById('history-modal').style.display = 'none';
        }

    </script>
</body>
</html>
